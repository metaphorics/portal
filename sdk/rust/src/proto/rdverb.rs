// This file is @generated by prost-build.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Packet {
    #[prost(enumeration = "PacketType", tag = "1")]
    pub r#type: i32,
    #[prost(bytes = "vec", tag = "2")]
    pub payload: ::prost::alloc::vec::Vec<u8>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RelayInfo {
    #[prost(message, optional, tag = "1")]
    pub identity: ::core::option::Option<super::rdsec::Identity>,
    #[prost(string, repeated, tag = "2")]
    pub address: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(message, repeated, tag = "3")]
    pub leases: ::prost::alloc::vec::Vec<Lease>,
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct RelayInfoRequest {}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RelayInfoResponse {
    #[prost(message, optional, tag = "1")]
    pub relay_info: ::core::option::Option<RelayInfo>,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Lease {
    #[prost(message, optional, tag = "1")]
    pub identity: ::core::option::Option<super::rdsec::Identity>,
    #[prost(int64, tag = "2")]
    pub expires: i64,
    #[prost(string, tag = "3")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "4")]
    pub alpn: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, tag = "5")]
    pub metadata: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct LeaseUpdateRequest {
    #[prost(message, optional, tag = "1")]
    pub lease: ::core::option::Option<Lease>,
    #[prost(bytes = "vec", tag = "2")]
    pub nonce: ::prost::alloc::vec::Vec<u8>,
    #[prost(int64, tag = "3")]
    pub timestamp: i64,
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct LeaseUpdateResponse {
    #[prost(enumeration = "ResponseCode", tag = "1")]
    pub code: i32,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct LeaseDeleteRequest {
    #[prost(message, optional, tag = "1")]
    pub identity: ::core::option::Option<super::rdsec::Identity>,
    #[prost(bytes = "vec", tag = "2")]
    pub nonce: ::prost::alloc::vec::Vec<u8>,
    #[prost(int64, tag = "3")]
    pub timestamp: i64,
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct LeaseDeleteResponse {
    #[prost(enumeration = "ResponseCode", tag = "1")]
    pub code: i32,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ConnectionRequest {
    #[prost(string, tag = "1")]
    pub lease_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub client_identity: ::core::option::Option<super::rdsec::Identity>,
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ConnectionResponse {
    #[prost(enumeration = "ResponseCode", tag = "1")]
    pub code: i32,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum PacketType {
    RelayInfoRequest = 0,
    RelayInfoResponse = 1,
    /// Authenticated
    LeaseUpdateRequest = 2,
    LeaseUpdateResponse = 3,
    /// Authenticated
    LeaseDeleteRequest = 4,
    LeaseDeleteResponse = 5,
    ConnectionRequest = 6,
    ConnectionResponse = 7,
}
impl PacketType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::RelayInfoRequest => "PACKET_TYPE_RELAY_INFO_REQUEST",
            Self::RelayInfoResponse => "PACKET_TYPE_RELAY_INFO_RESPONSE",
            Self::LeaseUpdateRequest => "PACKET_TYPE_LEASE_UPDATE_REQUEST",
            Self::LeaseUpdateResponse => "PACKET_TYPE_LEASE_UPDATE_RESPONSE",
            Self::LeaseDeleteRequest => "PACKET_TYPE_LEASE_DELETE_REQUEST",
            Self::LeaseDeleteResponse => "PACKET_TYPE_LEASE_DELETE_RESPONSE",
            Self::ConnectionRequest => "PACKET_TYPE_CONNECTION_REQUEST",
            Self::ConnectionResponse => "PACKET_TYPE_CONNECTION_RESPONSE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "PACKET_TYPE_RELAY_INFO_REQUEST" => Some(Self::RelayInfoRequest),
            "PACKET_TYPE_RELAY_INFO_RESPONSE" => Some(Self::RelayInfoResponse),
            "PACKET_TYPE_LEASE_UPDATE_REQUEST" => Some(Self::LeaseUpdateRequest),
            "PACKET_TYPE_LEASE_UPDATE_RESPONSE" => Some(Self::LeaseUpdateResponse),
            "PACKET_TYPE_LEASE_DELETE_REQUEST" => Some(Self::LeaseDeleteRequest),
            "PACKET_TYPE_LEASE_DELETE_RESPONSE" => Some(Self::LeaseDeleteResponse),
            "PACKET_TYPE_CONNECTION_REQUEST" => Some(Self::ConnectionRequest),
            "PACKET_TYPE_CONNECTION_RESPONSE" => Some(Self::ConnectionResponse),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ResponseCode {
    Unknown = 0,
    Accepted = 1,
    InvalidExpires = 2,
    InvalidIdentity = 3,
    InvalidName = 4,
    InvalidAlpn = 5,
    Rejected = 6,
}
impl ResponseCode {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unknown => "RESPONSE_CODE_UNKNOWN",
            Self::Accepted => "RESPONSE_CODE_ACCEPTED",
            Self::InvalidExpires => "RESPONSE_CODE_INVALID_EXPIRES",
            Self::InvalidIdentity => "RESPONSE_CODE_INVALID_IDENTITY",
            Self::InvalidName => "RESPONSE_CODE_INVALID_NAME",
            Self::InvalidAlpn => "RESPONSE_CODE_INVALID_ALPN",
            Self::Rejected => "RESPONSE_CODE_REJECTED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "RESPONSE_CODE_UNKNOWN" => Some(Self::Unknown),
            "RESPONSE_CODE_ACCEPTED" => Some(Self::Accepted),
            "RESPONSE_CODE_INVALID_EXPIRES" => Some(Self::InvalidExpires),
            "RESPONSE_CODE_INVALID_IDENTITY" => Some(Self::InvalidIdentity),
            "RESPONSE_CODE_INVALID_NAME" => Some(Self::InvalidName),
            "RESPONSE_CODE_INVALID_ALPN" => Some(Self::InvalidAlpn),
            "RESPONSE_CODE_REJECTED" => Some(Self::Rejected),
            _ => None,
        }
    }
}
