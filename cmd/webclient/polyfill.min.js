(function(){"use strict";const _=document.currentScript,S=window.WebSocket,w=window.location.hostname==="localhost"||window.location.hostname==="127.0.0.1"||window.location.hostname.endsWith(".localhost");function a(...h){w&&console.log(...h)}function g(){return`client-${Date.now()}-${Math.random().toString(36).substr(2,9)}`}function b(){const h=new Uint8Array(16);return crypto.getRandomValues(h),btoa(String.fromCharCode(...h))}function y(h,e){if(!h)throw new DOMException("Failed to construct 'WebSocket': 1 argument required, but only 0 present.");let t;try{t=new URL(h,window.location.href)}catch{throw new DOMException(`Failed to construct 'WebSocket': The URL '${h}' is invalid.`)}if(t.protocol!=="ws:"&&t.protocol!=="wss:")throw new DOMException(`Failed to construct 'WebSocket': The URL's scheme must be either 'ws' or 'wss'. '${t.protocol.slice(0,-1)}' is not allowed.`);let r=e;if(e!=null){if(typeof e=="string")r=[e];else if(Array.isArray(e))r=e;else throw new DOMException("Failed to construct 'WebSocket': The subprotocol '"+e+"' is invalid.");const o=new Set;for(const n of r){if(typeof n!="string")throw new DOMException("Failed to construct 'WebSocket': The subprotocol '"+n+"' is invalid.");if(n==="")throw new DOMException("Failed to construct 'WebSocket': The subprotocol '' is invalid.");if(o.has(n))throw new DOMException(`Failed to construct 'WebSocket': The subprotocol '${n}' is duplicated.`);o.add(n)}}return{parsedUrl:t,normalizedProtocols:r}}class c extends EventTarget{static CONNECTING=0;static OPEN=1;static CLOSING=2;static CLOSED=3;constructor(e,t){super();const{parsedUrl:r,normalizedProtocols:o}=y(e,t);this._url=r.href,this._protocols=o,this._parsedUrl=r,Object.defineProperty(this,"url",{get:()=>this._url,enumerable:!0,configurable:!0}),Object.defineProperty(this,"readyState",{get:()=>this._readyState,enumerable:!0,configurable:!0}),Object.defineProperty(this,"bufferedAmount",{get:()=>this._bufferedAmount,enumerable:!0,configurable:!0}),Object.defineProperty(this,"extensions",{get:()=>this._extensions,enumerable:!0,configurable:!0}),Object.defineProperty(this,"protocol",{get:()=>this._protocol,enumerable:!0,configurable:!0}),this._readyState=c.CONNECTING,this._bufferedAmount=0,this._extensions="",this._protocol="",this.binaryType="blob",this.onopen=null,this.onmessage=null,this.onerror=null,this.onclose=null,this._clientId=g(),this._connId=null,this._isClosed=!1,this._wsKey=b(),this._frameBuffer=new Uint8Array(0),this._setupMessageListener(),this._connect()}_postToServiceWorker(e){navigator.serviceWorker.controller.postMessage({clientId:this._clientId,connId:this._connId,...e})}_setupMessageListener(){navigator.serviceWorker.addEventListener("message",e=>{const t=e.data;if(t.clientId===this._clientId)switch(t.type){case"SDK_CONNECT_SUCCESS":this._handleConnectSuccess(t);break;case"SDK_CONNECT_ERROR":this._handleConnectError(t);break;case"SDK_DATA":this._handleData(t);break;case"SDK_DATA_CLOSE":this._handleDataClose(t);break;case"SDK_SEND_ERROR":this._handleSendError(t);break}})}_buildUpgradeRequest(){const e=(this._parsedUrl.pathname||"/")+(this._parsedUrl.search||""),t=this._parsedUrl.host;let r=`GET ${e} HTTP/1.1\r
`;if(r+=`Host: ${t}\r
`,r+=`Upgrade: websocket\r
`,r+=`Connection: Upgrade\r
`,r+=`Sec-WebSocket-Key: ${this._wsKey}\r
`,r+=`Sec-WebSocket-Version: 13\r
`,this._protocols){const o=Array.isArray(this._protocols)?this._protocols.join(", "):this._protocols;r+=`Sec-WebSocket-Protocol: ${o}\r
`}return r+=`\r
`,r}async _connect(){a("[WebSocket Polyfill] Connecting via Service Worker SDK to:",this._url);try{let e=this._parsedUrl.hostname;e=e.toLowerCase();const t=e.split(".")[0];a("[WebSocket Polyfill] Lease name:",t);const r=this._buildUpgradeRequest();a("[WebSocket Polyfill] Pipelining upgrade request with connect"),this._waitingForUpgrade=!0,this._upgradeBuffer=new Uint8Array(0),await navigator.serviceWorker.ready;const n=new TextEncoder().encode(r);navigator.serviceWorker.controller.postMessage({type:"SDK_CONNECT",clientId:this._clientId,leaseName:t,upgradeRequest:n})}catch(e){console.error("[WebSocket Polyfill] Failed to connect:",e),this._handleError(new Error(e))}}_handleConnectSuccess(e){this._connId=e.connId,a("[WebSocket Polyfill] E2EE tunnel established, upgrade request already sent (pipelined)")}_handleConnectError(e){console.error("[WebSocket Polyfill] Connection error:",e.error),this._handleError(new Error(e.error))}_handleData(e){const t=e.data;if(this._waitingForUpgrade){const r=new Uint8Array(this._upgradeBuffer.length+t.length);r.set(this._upgradeBuffer),r.set(t,this._upgradeBuffer.length),this._upgradeBuffer=r;const n=new TextDecoder().decode(this._upgradeBuffer),i=n.indexOf(`\r
\r
`);if(i===-1)return;const l=n.substring(0,i);if(a("[WebSocket Polyfill] Received upgrade response:",l),!l.includes("HTTP/1.1 101")&&!l.includes("HTTP/1.0 101")){this._handleError(new Error("WebSocket upgrade failed: "+l.split(`\r
`)[0]));return}const s=l.match(/Sec-WebSocket-Protocol:\s*(\S+)/i);s&&(this._protocol=s[1]),this._waitingForUpgrade=!1,this._readyState=c.OPEN,a("[WebSocket Polyfill] WebSocket connection established"),this.dispatchEvent(new Event("open"));const d=this._upgradeBuffer.slice(i+4);d.length>0&&this._processWebSocketFrames(d),this._upgradeBuffer=null;return}this._processWebSocketFrames(t)}_processWebSocketFrames(e){if(this._readyState!==c.OPEN)return;const t=new Uint8Array(this._frameBuffer.length+e.length);for(t.set(this._frameBuffer),t.set(e,this._frameBuffer.length),this._frameBuffer=t;this._frameBuffer.length>=2;){const r=this._frameBuffer[0],o=this._frameBuffer[1],n=(r&128)!==0,i=r&15,l=(o&128)!==0;let s=o&127,d=2;if(s===126){if(this._frameBuffer.length<4)return;s=this._frameBuffer[2]<<8|this._frameBuffer[3],d=4}else if(s===127){if(this._frameBuffer.length<10)return;s=this._frameBuffer[6]<<24|this._frameBuffer[7]<<16|this._frameBuffer[8]<<8|this._frameBuffer[9],d=10}if(l&&(d+=4),this._frameBuffer.length<d+s)return;const f=this._frameBuffer.slice(d,d+s);if(this._frameBuffer=this._frameBuffer.slice(d+s),i===1){const u=new TextDecoder().decode(f),p=new MessageEvent("message",{data:u,origin:this._parsedUrl.origin});this.dispatchEvent(p)}else if(i===2){let u;this.binaryType==="blob"?u=new Blob([f]):u=f.buffer;const p=new MessageEvent("message",{data:u,origin:this._parsedUrl.origin});this.dispatchEvent(p)}else if(i===8){let u=1e3,p="";f.length>=2&&(u=f[0]<<8|f[1],f.length>2&&(p=new TextDecoder().decode(f.slice(2)))),this._handleDataClose({code:u,reason:p})}else i===9&&this._sendPong(f)}}_sendPong(e){const t=this._createWebSocketFrame(10,e);this._postToServiceWorker({type:"SDK_SEND",data:t})}_createWebSocketFrame(e,t){const r=t.length;let o,n;r<126?(o=new Uint8Array(6+r),o[0]=128|e,o[1]=128|r,n=2):r<65536?(o=new Uint8Array(8+r),o[0]=128|e,o[1]=254,o[2]=r>>8&255,o[3]=r&255,n=4):(o=new Uint8Array(14+r),o[0]=128|e,o[1]=255,o[2]=0,o[3]=0,o[4]=0,o[5]=0,o[6]=r>>24&255,o[7]=r>>16&255,o[8]=r>>8&255,o[9]=r&255,n=10);const i=new Uint8Array(4);crypto.getRandomValues(i),o.set(i,n);const l=new Uint8Array(r);for(let s=0;s<r;s++)l[s]=t[s]^i[s%4];return o.set(l,n+4),o}_handleDataClose(e){if(this._isClosed)return;const t=e.code||1e3,r=e.reason||"";a("[WebSocket Polyfill] Connection closed, code:",t,"reason:",r),this._isClosed=!0,this._readyState=c.CLOSED;const o=new CloseEvent("close",{code:t,reason:r,wasClean:t===1e3});this.dispatchEvent(o)}_handleSendError(e){console.error("[WebSocket Polyfill] Send error:",e.error),this._handleError(new Error(e.error))}_handleError(e){console.error("[WebSocket Polyfill] Error occurred:",e);const t=new Event("error");t.error=e,this.dispatchEvent(t),this._isClosed||this._handleDataClose({code:1006,reason:e.message})}send(e){if(this._readyState!==c.OPEN)throw new DOMException("Failed to execute 'send' on 'WebSocket': Still in CONNECTING state.");if(!this._connId)throw new Error("Connection not established");try{let t,r;if(typeof e=="string")t=new TextEncoder().encode(e),r=1;else if(e instanceof ArrayBuffer)t=new Uint8Array(e),r=2;else if(e instanceof Uint8Array)t=e,r=2;else if(e instanceof Blob){e.arrayBuffer().then(n=>{const i=new Uint8Array(n),l=this._createWebSocketFrame(2,i);this._postToServiceWorker({type:"SDK_SEND",data:l})});return}else throw new Error("Unsupported data type");const o=this._createWebSocketFrame(r,t);this._postToServiceWorker({type:"SDK_SEND",data:o})}catch(t){console.error("[WebSocket Polyfill] Failed to send message:",t),this._handleError(t)}}close(e=1e3,t=""){if(!(this._isClosed||this._readyState===c.CLOSING)){if(a("[WebSocket Polyfill] Client initiated close, code:",e,"reason:",t),this._readyState=c.CLOSING,this._connId&&this._readyState===c.OPEN){const r=new TextEncoder().encode(t),o=new Uint8Array(2+r.length);o[0]=e>>8&255,o[1]=e&255,o.set(r,2);const n=this._createWebSocketFrame(8,o);this._postToServiceWorker({type:"SDK_SEND",data:n})}this._connId&&this._postToServiceWorker({type:"SDK_CLOSE"}),this._handleDataClose({code:e,reason:t})}}dispatchEvent(e){const t="on"+e.type;if(typeof this[t]=="function")try{this[t].call(this,e)}catch(r){console.error("Error in event handler:",r)}return super.dispatchEvent(e)}}function E(h){try{const e=new URL(h,window.location.href),t=window.location.origin;let r=e.origin;return e.protocol==="ws:"?r=r.replace("ws:","http:"):e.protocol==="wss:"&&(r=r.replace("wss:","https:")),r===t}catch{return!1}}window.WebSocket=function(e,t){return E(e)?(a("[WebSocket Polyfill] Using E2EE polyfill for same-origin connection:",e),new c(e,t)):(a("[WebSocket Polyfill] Using native WebSocket for cross-origin connection:",e),new S(e,t))},window.WebSocket.CONNECTING=c.CONNECTING,window.WebSocket.OPEN=c.OPEN,window.WebSocket.CLOSING=c.CLOSING,window.WebSocket.CLOSED=c.CLOSED,a("[WebSocket Polyfill] Initialized with E2EE and WebSocket protocol support"),_&&_.parentNode&&(_.parentNode.removeChild(_),a("[WebSocket Polyfill] Script tag removed"))})();
